const { executeQuery } = require('../config/db-config');
const { sql } = require('../config/db-config');
const jwt = require('jsonwebtoken');
const bcrypt = require('bcrypt');
const { generateToken } = require('../config/auth');
const { sendPasswordResetEmail } = require('../utils/emailUtils');
const crypto = require('crypto');
const SessionService = require('../services/sessionService');

// Şifre sıfırlama token tablosunu güvence altına al (self-healing)
async function ensurePasswordResetTokensTable() {
  try {
    // Tabloyu oluştur (yoksa)
    await sql`
      CREATE TABLE IF NOT EXISTS password_reset_tokens (
        id SERIAL PRIMARY KEY,
        email TEXT NOT NULL,
        token TEXT NOT NULL,
        user_type VARCHAR(20) NOT NULL CHECK (user_type IN ('courier','restaurant')),
        used BOOLEAN NOT NULL DEFAULT FALSE,
        created_at TIMESTAMP WITHOUT TIME ZONE NOT NULL DEFAULT NOW(),
        expires_at TIMESTAMP WITHOUT TIME ZONE NOT NULL
      )
    `;

    // used kolonu yoksa ekle
    await sql`
      ALTER TABLE password_reset_tokens
      ADD COLUMN IF NOT EXISTS used BOOLEAN NOT NULL DEFAULT FALSE
    `;

    // email, expires_at ve token için indeksler (token unique olacak şekilde)
    await sql`CREATE INDEX IF NOT EXISTS idx_prt_email ON password_reset_tokens(email)`;
    await sql`CREATE INDEX IF NOT EXISTS idx_prt_expires_at ON password_reset_tokens(expires_at)`;
    await sql`CREATE UNIQUE INDEX IF NOT EXISTS ux_prt_token ON password_reset_tokens(token)`;

    // id kolonunun identity/sequence ile arttığından emin ol
    await sql`
      DO $$
      DECLARE
        col_is_identity TEXT;
        seq_exists BOOLEAN;
      BEGIN
        SELECT is_identity INTO col_is_identity
        FROM information_schema.columns
        WHERE table_schema = 'app' AND table_name = 'password_reset_tokens' AND column_name = 'id';

        IF col_is_identity IS DISTINCT FROM 'YES' THEN
          BEGIN
            -- Kimlik eklemeyi dene (bazı eski sürümlerde veya mevcut default varken hata verebilir)
            EXECUTE 'ALTER TABLE password_reset_tokens ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY';
          EXCEPTION WHEN others THEN
            -- Geri dönüş: sequence oluştur ve default olarak ayarla (eğer yoksa)
            SELECT EXISTS (
              SELECT 1 FROM pg_class c
              JOIN pg_namespace n ON n.oid = c.relnamespace
              WHERE c.relkind = 'S' AND c.relname = 'password_reset_tokens_id_seq' AND n.nspname = 'app'
            ) INTO seq_exists;

            IF NOT seq_exists THEN
              EXECUTE 'CREATE SEQUENCE app.password_reset_tokens_id_seq';
              EXECUTE 'SELECT setval(''app.password_reset_tokens_id_seq'', COALESCE((SELECT MAX(id) FROM app.password_reset_tokens), 0))';
            END IF;

            -- Varsayılanı sequence'e bağla
            BEGIN
              EXECUTE 'ALTER TABLE password_reset_tokens ALTER COLUMN id SET DEFAULT nextval(''app.password_reset_tokens_id_seq'')';
            EXCEPTION WHEN others THEN
              -- Eğer default zaten ayarlıysa önemseme
              NULL;
            END;
          END;
        END IF;
      END $$;
    `;
  } catch (e) {
    // Burada hata yükseltmeyelim; asıl insert/reset akışı kendi hatasını üretir
    console.warn('password_reset_tokens tablo kontrolü uyarısı:', e?.message || e);
  }
}

// This is a unified login handler with bcrypt support and session management
const unifiedLogin = async (req, res) => {
    try {
        const { email, password } = req.body;

        if (!email || !password) {
            return res.status(400).json({ success: false, message: 'Email/Telefon ve şifre gerekli.' });
        }

        // Get device info and IP address
        const deviceInfo = req.headers['user-agent'] || 'Unknown Device';
        const ipAddress = req.ip || req.connection.remoteAddress || 'Unknown IP';

        // Check if input is phone number or email
        const isPhoneNumber = /^[\d\s\-\+\(\)]+$/.test(email.replace(/\s/g, ''));
        
        // Check restaurants first
        let restaurants = [];
        if (isPhoneNumber) {
            restaurants = await sql`
                SELECT id, name as restaurant_name, email, phone, password FROM restaurants 
                WHERE phone = ${email} OR phone = ${email.replace(/\s/g, '')}
            `;
        } else {
            restaurants = await sql`
                SELECT id, name as restaurant_name, email, phone, password FROM restaurants 
                WHERE email = ${email}
            `;
        }

        if (restaurants.length > 0) {
            const restaurant = restaurants[0];

            // Verify password with plain text comparison
            if (restaurant.password === password) {
                const user = {
                    id: restaurant.id,
                    name: restaurant.restaurant_name,
                    email: restaurant.email,
                    phone: restaurant.phone,
                    role: 'restaurant'
                };

                const token = generateToken(user, 'restaurant');

                // Session management - daha robust hata kontrolü ile
                let invalidatedSessions = [];
                try {
                    invalidatedSessions = await SessionService.invalidateUserSessions(user.id, 'restaurant');
                    await SessionService.createSession(user.id, 'restaurant', token, deviceInfo, ipAddress);
                } catch (sessionError) {
                    console.error('Session yönetimi hatası (restaurant):', sessionError);
                    // Session hatası olsa bile login'e devam et - çünkü session opsiyonel
                }

                // Socket.io ile diğer oturumlara logout sinyali gönder (tekil socketId'lere)
                try {
                    if (invalidatedSessions.length > 0) {
                        const io = req.app.get('io');
                        if (io) {
                            const uniqueSocketIds = new Set(
                                invalidatedSessions
                                  .map(s => s.socket_id)
                                  .filter(Boolean)
                            );

                            uniqueSocketIds.forEach(socketId => {
                                io.to(socketId).emit('forceLogout', {
                                    reason: 'CONCURRENT_SESSION',
                                    message: 'Hesabınıza başka bir cihazdan giriş yapıldı. Güvenlik nedeniyle çıkış yapılıyor.'
                                });
                            });
                        }
                    }
                } catch (socketError) {
                    console.error('Socket.io logout sinyali hatası (restaurant):', socketError);
                    // Socket hatası login'i engellemez
                }

                return res.status(200).json({
                    success: true,
                    message: 'Restoran girişi başarılı',
                    token,
                    user
                });
            }
        }

        // Check couriers
        let couriers = [];
        if (isPhoneNumber) {
            couriers = await sql`
                SELECT id, name as courier_name, email, phone, password FROM couriers 
                WHERE phone = ${email} OR phone = ${email.replace(/\s/g, '')}
            `;
        } else {
            couriers = await sql`
                SELECT id, name as courier_name, email, phone, password FROM couriers 
                WHERE email = ${email}
            `;
        }

        if (couriers.length > 0) {
            const courier = couriers[0];

            // Verify password with plain text comparison
            if (courier.password === password) {
                const user = {
                    id: courier.id,
                    name: courier.courier_name,
                    email: courier.email,
                    phone: courier.phone,
                    role: 'courier'
                };

                const token = generateToken(user, 'courier');

                // Session management - daha robust hata kontrolü ile
                let invalidatedSessions = [];
                try {
                    invalidatedSessions = await SessionService.invalidateUserSessions(user.id, 'courier');
                    await SessionService.createSession(user.id, 'courier', token, deviceInfo, ipAddress);
                } catch (sessionError) {
                    console.error('Session yönetimi hatası (courier):', sessionError);
                    // Session hatası olsa bile login'e devam et - çünkü session opsiyonel
                }

                // Socket.io ile diğer oturumlara logout sinyali gönder (tekil socketId'lere)
                try {
                    if (invalidatedSessions.length > 0) {
                        const io = req.app.get('io');
                        if (io) {
                            const uniqueSocketIds = new Set(
                                invalidatedSessions
                                  .map(s => s.socket_id)
                                  .filter(Boolean)
                            );

                            uniqueSocketIds.forEach(socketId => {
                                io.to(socketId).emit('forceLogout', {
                                    reason: 'CONCURRENT_SESSION',
                                    message: 'Hesabınıza başka bir cihazdan giriş yapıldı. Güvenlik nedeniyle çıkış yapılıyor.'
                                });
                            });
                        }
                    }
                } catch (socketError) {
                    console.error('Socket.io logout sinyali hatası (courier):', socketError);
                    // Socket hatası login'i engellemez
                }

                return res.status(200).json({
                    success: true,
                    message: 'Kurye girişi başarılı',
                    token,
                    user
                });
            }
        }

        return res.status(401).json({
            success: false,
            message: 'Geçersiz email/telefon veya şifre'
        });

    } catch (error) {
        console.error('Birleşik giriş sırasında hata:', error);
        return res.status(500).json({ success: false, message: 'Giriş sırasında sunucu hatası oluştu.' });
    }
};

const loginUser = async (req, res) => {
  try {
    const { email, password } = req.body;

    if (!email || !password) {
      return res.status(400).json({
        success: false,
        message: 'Email/Telefon ve şifre gerekli'
      });
    }

    // Check if input is phone number or email
    const isPhoneNumber = /^[\d\s\-\+\(\)]+$/.test(email.replace(/\s/g, ''));

    // Check restaurants first
    let restaurantRecords = [];
    if (isPhoneNumber) {
      // Search by phone number
      restaurantRecords = await sql`
        SELECT 
          id, 
          name, 
          email, 
          phone,
          password,
          'restaurant' as role 
        FROM restaurants 
        WHERE phone = ${email} OR phone = ${email.replace(/\s/g, '')}
      `;
    } else {
      // Search by email
      restaurantRecords = await sql`
        SELECT 
          id, 
          name, 
          email, 
          phone,
          password,
          'restaurant' as role 
        FROM restaurants 
        WHERE email = ${email}
      `;
    }
    
    if (restaurantRecords.length > 0) {
      const restaurant = restaurantRecords[0];
      
      // Verify password with plain text comparison
      if (restaurant.password === password) {
        // Generate JWT token
        const user = {
          id: restaurant.id,
          email: restaurant.email,
          name: restaurant.name,
          phone: restaurant.phone,
          role: 'restaurant'
        };
        
        const token = generateToken(user, 'restaurant');
        
        return res.status(200).json({
          success: true,
          message: 'Giriş başarılı',
          token,
          user
        });
      }
    }

    // Check couriers
    let courierRecords = [];
    if (isPhoneNumber) {
      // Search by phone number
      courierRecords = await sql`
        SELECT 
          id, 
          name, 
          email, 
          phone,
          password,
          'courier' as role 
        FROM couriers 
        WHERE phone = ${email} OR phone = ${email.replace(/\s/g, '')}
      `;
    } else {
      // Search by email
      courierRecords = await sql`
        SELECT 
          id, 
          name, 
          email, 
          phone,
          password,
          'courier' as role 
        FROM couriers 
        WHERE email = ${email}
      `;
    }
    
    if (courierRecords.length > 0) {
      const courier = courierRecords[0];
      
      // Verify password with plain text comparison
      if (courier.password === password) {
        // Generate JWT token
        const user = {
          id: courier.id,
          email: courier.email,
          name: courier.name,
          phone: courier.phone,
          role: 'courier'
        };
        
        const token = generateToken(user, 'courier');
        
        return res.status(200).json({
          success: true,
          message: 'Giriş başarılı',
          token,
          user
        });
      }
    }

    return res.status(401).json({
      success: false,
      message: 'Geçersiz email/telefon veya şifre'
    });

  } catch (error) {
    console.error('Login error:', error);
    return res.status(500).json({
      success: false,
      message: 'Sunucu hatası'
    });
  }
};

// Şifre sıfırlama talebi
const requestPasswordReset = async (req, res) => {
    try {
        await ensurePasswordResetTokensTable();
        const { email } = req.body;

        if (!email) {
            return res.status(400).json({ 
                success: false, 
                message: 'E-posta adresi gerekli' 
            });
        }

        // E-posta formatını kontrol et
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        if (!emailRegex.test(email)) {
            return res.status(400).json({ 
                success: false, 
                message: 'Geçerli bir e-posta adresi girin' 
            });
        }

        // Önce kurye tablosunda ara
        const courier = await sql`
            SELECT id, name, email FROM couriers WHERE email = ${email}
        `;

        // Sonra restoran tablosunda ara
        const restaurant = await sql`
            SELECT id, name, email FROM restaurants WHERE email = ${email}
        `;

        if (courier.length === 0 && restaurant.length === 0) {
            return res.status(404).json({ 
                success: false, 
                message: 'Bu e-posta adresi ile kayıtlı kullanıcı bulunamadı' 
            });
        }

        // Rastgele token oluştur
        const resetToken = crypto.randomBytes(32).toString('hex');
        const expiresAt = new Date(Date.now() + 3600000); // 1 saat sonra
        
        let userType = '';
        let userName = '';

        if (courier.length > 0) {
            userType = 'courier';
            userName = courier[0].name;
        } else {
            userType = 'restaurant';
            userName = restaurant[0].name;
        }

        // Eski token'ları temizle
        await sql`
            DELETE FROM password_reset_tokens 
            WHERE email = ${email} AND expires_at < NOW()
        `;

        // Yeni token'ı kaydet
        await sql`
            INSERT INTO password_reset_tokens (email, token, user_type, expires_at)
            VALUES (${email}, ${resetToken}, ${userType}, ${expiresAt})
        `;

        // E-posta gönder
        const emailResult = await sendPasswordResetEmail(email, resetToken, userType);

        if (emailResult.success) {
            return res.status(200).json({
                success: true,
                message: 'Şifre sıfırlama e-postası gönderildi. Lütfen e-posta kutunuzu kontrol edin.'
            });
        } else {
            return res.status(500).json({
                success: false,
                message: 'E-posta gönderilemedi. Lütfen daha sonra tekrar deneyin.'
            });
        }

    } catch (error) {
        console.error('Şifre sıfırlama talebi hatası:', error);
        return res.status(500).json({ 
            success: false, 
            message: 'Sunucu hatası oluştu' 
        });
    }
};

// Şifre sıfırlama
const resetPassword = async (req, res) => {
    try {
        await ensurePasswordResetTokensTable();
        const { token, newPassword } = req.body;

        if (!token || !newPassword) {
            return res.status(400).json({ 
                success: false, 
                message: 'Token ve yeni şifre gerekli' 
            });
        }

        if (newPassword.length < 6) {
            return res.status(400).json({ 
                success: false, 
                message: 'Şifre en az 6 karakter olmalıdır' 
            });
        }

        // Token'ı kontrol et
        const resetTokenRecord = await sql`
            SELECT * FROM password_reset_tokens 
            WHERE token = ${token} AND expires_at > NOW() AND used = false
        `;

        if (resetTokenRecord.length === 0) {
            return res.status(400).json({ 
                success: false, 
                message: 'Geçersiz veya süresi dolmuş token' 
            });
        }

        const tokenData = resetTokenRecord[0];

        // Şifreyi güncelle
        if (tokenData.user_type === 'courier') {
            await sql`
                UPDATE couriers 
                SET password = ${newPassword}, updated_at = NOW() 
                WHERE email = ${tokenData.email}
            `;
        } else if (tokenData.user_type === 'restaurant') {
            await sql`
                UPDATE restaurants 
                SET password = ${newPassword}, updated_at = NOW() 
                WHERE email = ${tokenData.email}
            `;
        }

        // Token'ı kullanıldı olarak işaretle
        await sql`
            UPDATE password_reset_tokens 
            SET used = true 
            WHERE token = ${token}
        `;

        return res.status(200).json({
            success: true,
            message: 'Şifre başarıyla güncellendi. Yeni şifrenizle giriş yapabilirsiniz.'
        });

    } catch (error) {
        console.error('Şifre sıfırlama hatası:', error);
        return res.status(500).json({ 
            success: false, 
            message: 'Sunucu hatası oluştu' 
    });
  }
};

// Logout function with session management
const logout = async (req, res) => {
    try {
        const token = req.headers.authorization?.replace('Bearer ', '');
        
        if (!token) {
            return res.status(400).json({ 
                success: false, 
                message: 'Token gerekli' 
            });
        }

        // Session'ı invalidate et
        const invalidatedSession = await SessionService.invalidateSession(token);
        
        if (invalidatedSession) {
            console.log(`🔐 Kullanıcı çıkış yaptı - User: ${invalidatedSession.user_id}, Role: ${invalidatedSession.user_role}`);
        }

        return res.status(200).json({
            success: true,
            message: 'Çıkış başarılı'
        });

    } catch (error) {
        console.error('Çıkış sırasında hata:', error);
        return res.status(500).json({ 
            success: false, 
            message: 'Çıkış sırasında sunucu hatası oluştu' 
        });
    }
};

// @desc    Refresh user token (extend session)
// @route   POST /api/refresh-token
// @access  Private
const refreshToken = async (req, res) => {
    try {
        const { user, session } = req; // authMiddleware'dan geliyor
        
        // Mevcut token'ı al
        const currentToken = req.headers.authorization.split(' ')[1];
        
        // Yeni token oluştur (aynı payload ile)
        const { generateToken } = require('../config/auth');
        const newToken = generateToken(
            { 
                id: user.id, 
                name: user.name, 
                role: user.aud || user.role 
            }, 
            user.aud || user.role
        );
        
        // Yeni session oluştur ve eskisini invalidate et
        const SessionService = require('../services/sessionService');
        await SessionService.invalidateSession(currentToken);
        
        const newSession = await SessionService.createSession(
            user.id,
            user.aud || user.role,
            newToken,
            session.device_info,
            session.ip_address,
            session.socket_id
        );
        
        console.log(`🔄 Token refresh edildi - User: ${user.id}, Role: ${user.aud || user.role}`);
        
        return res.status(200).json({
            success: true,
            message: 'Token başarıyla yenilendi',
            token: newToken,
            user: {
                id: user.id,
                name: user.name,
                role: user.aud || user.role
            }
        });

    } catch (error) {
        console.error('Token refresh sırasında hata:', error);
        return res.status(500).json({ 
            success: false, 
            message: 'Token yenileme sırasında sunucu hatası oluştu' 
        });
    }
};

// @desc    Delete current user's account (courier or restaurant)
// @route   DELETE /api/account
// @access  Private
const deleteAccount = async (req, res) => {
    try {
        const { sql } = require('../config/db-config');
        const SessionService = require('../services/sessionService');
        const userId = req.user?.id;
        const userRole = req.user?.aud || req.user?.role;

        if (!userId || !userRole) {
            return res.status(400).json({ success: false, message: 'Kullanıcı bilgileri bulunamadı' });
        }

        // Push token'ları devre dışı bırak
        try {
            await sql`
                UPDATE push_tokens 
                SET is_active = false, updated_at = NOW()
                WHERE user_id = ${userId} AND user_type = ${userRole}
            `;
        } catch (e) {
            console.warn('Push token devre dışı bırakma hata/uyarı:', e?.message || e);
        }

        // Oturumları geçersiz kıl
        try {
            await SessionService.invalidateUserSessions(userId, userRole);
        } catch (e) {
            console.warn('Session invalidate hata/uyarı:', e?.message || e);
        }

        // Rol bazlı hesap silme
        if (userRole === 'courier') {
            try {
                const deleted = await sql`
                    DELETE FROM couriers
                    WHERE id = ${userId}
                    RETURNING id
                `;
                if (deleted.length === 0) {
                    return res.status(404).json({ success: false, message: 'Kurye hesabı bulunamadı' });
                }
            } catch (error) {
                console.error('Kurye hesabı silinirken hata:', error);
                return res.status(500).json({ success: false, message: 'Hesap silinirken sunucu hatası oluştu' });
            }
        } else if (userRole === 'restaurant') {
            try {
                // İlişkili alanları temizle
                await sql`DELETE FROM restaurant_delivery_prices WHERE restaurant_id = ${userId}`;

                const deleted = await sql`
                    DELETE FROM restaurants
                    WHERE id = ${userId}
                    RETURNING id
                `;
                if (deleted.length === 0) {
                    return res.status(404).json({ success: false, message: 'Restoran hesabı bulunamadı' });
                }
            } catch (error) {
                console.error('Restoran hesabı silinirken hata:', error);
                return res.status(500).json({ success: false, message: 'Hesap silinirken sunucu hatası oluştu' });
            }
        } else {
            return res.status(400).json({ success: false, message: 'Geçersiz kullanıcı rolü' });
        }

        return res.status(200).json({
            success: true,
            message: 'Hesap başarıyla silindi'
        });

    } catch (error) {
        console.error('Hesap silme sırasında hata:', error);
        return res.status(500).json({ success: false, message: 'Hesap silme sırasında sunucu hatası oluştu' });
    }
};

module.exports = {
    unifiedLogin,
    loginUser,
    requestPasswordReset,
    resetPassword,
    logout,
    refreshToken,
    deleteAccount
}; 